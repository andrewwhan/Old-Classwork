PA3, Andrew HAn
PA3 is a program that takes plain text files and the name of an output file as arguments. It then reads from those plain text files and generates a list of all words that appeared in the input files as well as how many times each word appeared. Lastly, it prints the total number of different words that appeared in the text files. It can be compiled in Eclipse by building the project; and it can be cleaned using the "Clean Project" option.
The program takes the following arguments:
outputFile inputFile1 inputFile2 ...
The program accepts an indeterminate number of input files.
The files test1.txt and test2.txt are sample input files, a couple of essays from an introductory level philosophy course. output1.txt and output2.txt are the output files generated by running the program with the arguments
output1.txt test1.txt
and 
output2.txt test2.txt
They serve as my two non-trivial test cases for my program.
My program consists of 3 .c files and 2 .h files.

Main.c is the file that contains the main() function, accepts the arguments, and calls functions in other files to accomplish the task.

IO.c contains the functions that process input from the input files and also contains the function that handles printing out information from the tree.

IO.h is the header file for IO.c and also includes Tree.h since the functions from IO.c require the use of functions from Tree.c

Tree.c declares the struct for the tree and contains the functions that operate on the tree.

Tree.h is the header file for Tree.c and also typedefs the node struct so that it can be referred to more easily throughout the rest of the program.

My program, after declaring variables, loops over each input file. Since the input files start at argv[2], my loop works as intended because it starts at i=2 and goes until i==(argc-1), which would be the final argument, since an array[n]'s index starts at 0 and goes to n-1. For each input file, I pass the pointer to the file as well as a pointer to the location in memory of my root to parsefile(), so that the memory can be appropriately malloc'ed.
parsefile() uses a function called readword() to read from the input file until reaching terminating punctuation or whitespace to recognize words.
In readword() I impose a hard limit to the length of a word to 31 characters. I allocate space for 32 characters, counting the null character at the end of a string. My while loop that retrieves individual characters functions as intended, since max it will iterate 31 times for i = 1 to i = 31, meaning it will never create a string longer than 31 characters. I then use a loop to iterate over each character in the string, checking if at least one character is an alphabetical character to ensure that it is a word that I am accepting. Since this loops for i=0 to i=30, or 31 times, it will iterate over every character that could possibly be alphabetical; the 32nd character would be a null character. This word is dynamically allocated in the heap so that it can be returned.
parsefile() then takes the word returned by readword() and adds it to the tree using addword(). addword() follows the typical structure for adding elements to a binary search tree, following along left and right branches as necessary until either finding the right word and incrementing the count or reaching a null branch and allocating the memory for a new node in the tree as well as the memory to store the word.
After the word has been added to the tree, parsefile() frees the memory for the word that was previously allocated in readword().
After opening each file and processing the words inside, I close the file. After all input files have been processed, I open an output file to be written to and call traverseandprint() to process my tree and print the words and their occurrence in alphabetical order. traverseandprint() initializes an integer to hold the number of different words and passes a pointer to this integer to traverse() so that each time a word from the tree is printed, I can update the count. traverse() traverses the tree in-order so that the words are printed in alphabetical order. traverseandprint() then prints the final lines indicating the total number of different words. Afterwards, I close the output file and free all the memory allocated in the tree by traversing it in post-order, freeing the memory allocated to the word that a node held, then the node itself.